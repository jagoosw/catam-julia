<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_zbz3yiivmxva-0>li:before{content:"\0025cf  "}ul.lst-kix_brtyuticwpei-7{list-style-type:none}.lst-kix_zbz3yiivmxva-3>li:before{content:"\0025cf  "}ul.lst-kix_brtyuticwpei-6{list-style-type:none}ul.lst-kix_brtyuticwpei-8{list-style-type:none}.lst-kix_zbz3yiivmxva-1>li:before{content:"\0025cb  "}.lst-kix_zbz3yiivmxva-2>li:before{content:"\0025a0  "}.lst-kix_zbz3yiivmxva-7>li:before{content:"\0025cb  "}.lst-kix_zbz3yiivmxva-8>li:before{content:"\0025a0  "}.lst-kix_74ske6hyiwzb-3>li:before{content:"\0025cf  "}ul.lst-kix_brtyuticwpei-1{list-style-type:none}ul.lst-kix_brtyuticwpei-0{list-style-type:none}ul.lst-kix_brtyuticwpei-3{list-style-type:none}.lst-kix_74ske6hyiwzb-4>li:before{content:"\0025cb  "}.lst-kix_74ske6hyiwzb-5>li:before{content:"\0025a0  "}ul.lst-kix_brtyuticwpei-2{list-style-type:none}ul.lst-kix_brtyuticwpei-5{list-style-type:none}.lst-kix_ka2oxzrbkniw-2>li:before{content:"\0025a0  "}ul.lst-kix_brtyuticwpei-4{list-style-type:none}.lst-kix_zbz3yiivmxva-4>li:before{content:"\0025cb  "}.lst-kix_74ske6hyiwzb-6>li:before{content:"\0025cf  "}.lst-kix_74ske6hyiwzb-7>li:before{content:"\0025cb  "}.lst-kix_8q74ckljj7r6-2>li:before{content:"\0025a0  "}.lst-kix_ka2oxzrbkniw-1>li:before{content:"\0025cb  "}.lst-kix_zbz3yiivmxva-5>li:before{content:"\0025a0  "}.lst-kix_zbz3yiivmxva-6>li:before{content:"\0025cf  "}.lst-kix_ka2oxzrbkniw-0>li:before{content:"\0025cf  "}.lst-kix_8q74ckljj7r6-1>li:before{content:"\0025cb  "}.lst-kix_ka2oxzrbkniw-7>li:before{content:"\0025cb  "}ol.lst-kix_aj4nely7012k-7.start{counter-reset:lst-ctn-kix_aj4nely7012k-7 0}.lst-kix_8q74ckljj7r6-0>li:before{content:"\0025cf  "}.lst-kix_74ske6hyiwzb-8>li:before{content:"\0025a0  "}.lst-kix_ka2oxzrbkniw-6>li:before{content:"\0025cf  "}.lst-kix_ka2oxzrbkniw-3>li:before{content:"\0025cf  "}.lst-kix_aj4nely7012k-0>li{counter-increment:lst-ctn-kix_aj4nely7012k-0}.lst-kix_ka2oxzrbkniw-5>li:before{content:"\0025a0  "}.lst-kix_ka2oxzrbkniw-4>li:before{content:"\0025cb  "}.lst-kix_ka2oxzrbkniw-8>li:before{content:"\0025a0  "}.lst-kix_k03hqnpiq03o-0>li:before{content:"\0025cf  "}.lst-kix_k03hqnpiq03o-2>li:before{content:"\0025a0  "}.lst-kix_k03hqnpiq03o-1>li:before{content:"\0025cb  "}.lst-kix_sols1i8ldw7r-1>li:before{content:"\0025cb  "}.lst-kix_sols1i8ldw7r-0>li:before{content:"\0025cf  "}ul.lst-kix_74ske6hyiwzb-3{list-style-type:none}ul.lst-kix_74ske6hyiwzb-2{list-style-type:none}ul.lst-kix_74ske6hyiwzb-1{list-style-type:none}ul.lst-kix_74ske6hyiwzb-0{list-style-type:none}.lst-kix_sols1i8ldw7r-7>li:before{content:"\0025cb  "}.lst-kix_sols1i8ldw7r-8>li:before{content:"\0025a0  "}.lst-kix_8q74ckljj7r6-3>li:before{content:"\0025cf  "}.lst-kix_8q74ckljj7r6-4>li:before{content:"\0025cb  "}.lst-kix_sols1i8ldw7r-2>li:before{content:"\0025a0  "}.lst-kix_8q74ckljj7r6-5>li:before{content:"\0025a0  "}.lst-kix_8q74ckljj7r6-7>li:before{content:"\0025cb  "}ul.lst-kix_e2t2rmnqe10-5{list-style-type:none}.lst-kix_74ske6hyiwzb-2>li:before{content:"\0025a0  "}ul.lst-kix_e2t2rmnqe10-4{list-style-type:none}.lst-kix_8q74ckljj7r6-8>li:before{content:"\0025a0  "}ul.lst-kix_e2t2rmnqe10-3{list-style-type:none}.lst-kix_8q74ckljj7r6-6>li:before{content:"\0025cf  "}ul.lst-kix_e2t2rmnqe10-2{list-style-type:none}.lst-kix_sols1i8ldw7r-3>li:before{content:"\0025cf  "}ul.lst-kix_e2t2rmnqe10-1{list-style-type:none}.lst-kix_74ske6hyiwzb-0>li:before{content:"\0025cf  "}.lst-kix_74ske6hyiwzb-1>li:before{content:"\0025cb  "}ul.lst-kix_e2t2rmnqe10-0{list-style-type:none}.lst-kix_sols1i8ldw7r-4>li:before{content:"\0025cb  "}.lst-kix_sols1i8ldw7r-5>li:before{content:"\0025a0  "}ul.lst-kix_74ske6hyiwzb-8{list-style-type:none}ul.lst-kix_74ske6hyiwzb-7{list-style-type:none}ul.lst-kix_74ske6hyiwzb-6{list-style-type:none}ul.lst-kix_e2t2rmnqe10-8{list-style-type:none}ul.lst-kix_74ske6hyiwzb-5{list-style-type:none}.lst-kix_sols1i8ldw7r-6>li:before{content:"\0025cf  "}ul.lst-kix_e2t2rmnqe10-7{list-style-type:none}ul.lst-kix_74ske6hyiwzb-4{list-style-type:none}ul.lst-kix_e2t2rmnqe10-6{list-style-type:none}.lst-kix_aj4nely7012k-4>li{counter-increment:lst-ctn-kix_aj4nely7012k-4}ul.lst-kix_gepharm975nz-0{list-style-type:none}ul.lst-kix_gepharm975nz-1{list-style-type:none}ul.lst-kix_gepharm975nz-2{list-style-type:none}ul.lst-kix_gepharm975nz-3{list-style-type:none}ul.lst-kix_izk41jo74l0l-0{list-style-type:none}ul.lst-kix_izk41jo74l0l-1{list-style-type:none}ul.lst-kix_izk41jo74l0l-2{list-style-type:none}ul.lst-kix_izk41jo74l0l-3{list-style-type:none}ul.lst-kix_izk41jo74l0l-4{list-style-type:none}ul.lst-kix_izk41jo74l0l-5{list-style-type:none}ul.lst-kix_izk41jo74l0l-6{list-style-type:none}ul.lst-kix_izk41jo74l0l-7{list-style-type:none}ul.lst-kix_iwdebqq8hf5j-0{list-style-type:none}ul.lst-kix_izk41jo74l0l-8{list-style-type:none}.lst-kix_o30o65ygwqqk-8>li:before{content:"\0025a0  "}ul.lst-kix_iwdebqq8hf5j-3{list-style-type:none}ul.lst-kix_iwdebqq8hf5j-4{list-style-type:none}ul.lst-kix_iwdebqq8hf5j-1{list-style-type:none}ul.lst-kix_iwdebqq8hf5j-2{list-style-type:none}ul.lst-kix_iwdebqq8hf5j-7{list-style-type:none}ul.lst-kix_iwdebqq8hf5j-8{list-style-type:none}ul.lst-kix_iwdebqq8hf5j-5{list-style-type:none}ul.lst-kix_iwdebqq8hf5j-6{list-style-type:none}.lst-kix_o30o65ygwqqk-6>li:before{content:"\0025cf  "}.lst-kix_aj4nely7012k-3>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-3,decimal) ". "}ol.lst-kix_aj4nely7012k-0.start{counter-reset:lst-ctn-kix_aj4nely7012k-0 0}.lst-kix_aj4nely7012k-3>li{counter-increment:lst-ctn-kix_aj4nely7012k-3}.lst-kix_aj4nely7012k-5>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-5,lower-roman) ". "}ul.lst-kix_o30o65ygwqqk-1{list-style-type:none}ul.lst-kix_o30o65ygwqqk-2{list-style-type:none}ul.lst-kix_o30o65ygwqqk-3{list-style-type:none}ul.lst-kix_o30o65ygwqqk-4{list-style-type:none}ul.lst-kix_o30o65ygwqqk-0{list-style-type:none}.lst-kix_k03hqnpiq03o-3>li:before{content:"\0025cf  "}ul.lst-kix_o30o65ygwqqk-5{list-style-type:none}.lst-kix_aj4nely7012k-1>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-1,lower-latin) ". "}ul.lst-kix_o30o65ygwqqk-6{list-style-type:none}ul.lst-kix_o30o65ygwqqk-7{list-style-type:none}ul.lst-kix_o30o65ygwqqk-8{list-style-type:none}.lst-kix_imtbhan3v8dd-2>li:before{content:"\0025a0  "}.lst-kix_k03hqnpiq03o-5>li:before{content:"\0025a0  "}ul.lst-kix_qjrdt59nqqfa-3{list-style-type:none}ul.lst-kix_qjrdt59nqqfa-4{list-style-type:none}ul.lst-kix_qjrdt59nqqfa-1{list-style-type:none}ul.lst-kix_qjrdt59nqqfa-2{list-style-type:none}.lst-kix_k03hqnpiq03o-7>li:before{content:"\0025cb  "}.lst-kix_imtbhan3v8dd-4>li:before{content:"\0025cb  "}ul.lst-kix_qjrdt59nqqfa-0{list-style-type:none}.lst-kix_imtbhan3v8dd-6>li:before{content:"\0025cf  "}.lst-kix_aj4nely7012k-7>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-7,lower-latin) ". "}ul.lst-kix_kahinyjwemck-0{list-style-type:none}.lst-kix_imtbhan3v8dd-8>li:before{content:"\0025a0  "}ul.lst-kix_kahinyjwemck-1{list-style-type:none}ul.lst-kix_kahinyjwemck-4{list-style-type:none}ul.lst-kix_kahinyjwemck-5{list-style-type:none}ul.lst-kix_kahinyjwemck-2{list-style-type:none}ul.lst-kix_kahinyjwemck-3{list-style-type:none}ul.lst-kix_kahinyjwemck-8{list-style-type:none}ul.lst-kix_kahinyjwemck-6{list-style-type:none}ul.lst-kix_kahinyjwemck-7{list-style-type:none}.lst-kix_o30o65ygwqqk-0>li:before{content:"\0025cf  "}.lst-kix_o30o65ygwqqk-4>li:before{content:"\0025cb  "}ol.lst-kix_aj4nely7012k-2.start{counter-reset:lst-ctn-kix_aj4nely7012k-2 0}.lst-kix_4gr8286u97kq-7>li:before{content:"\0025cb  "}.lst-kix_o30o65ygwqqk-2>li:before{content:"\0025a0  "}.lst-kix_8br8rmq8ditp-1>li:before{content:"\0025cb  "}.lst-kix_4gr8286u97kq-1>li:before{content:"\0025cb  "}.lst-kix_4gr8286u97kq-3>li:before{content:"\0025cf  "}ul.lst-kix_qjrdt59nqqfa-7{list-style-type:none}ul.lst-kix_qjrdt59nqqfa-8{list-style-type:none}ul.lst-kix_qjrdt59nqqfa-5{list-style-type:none}ul.lst-kix_qjrdt59nqqfa-6{list-style-type:none}.lst-kix_4gr8286u97kq-5>li:before{content:"\0025a0  "}.lst-kix_8br8rmq8ditp-3>li:before{content:"\0025cf  "}.lst-kix_8br8rmq8ditp-8>li:before{content:"\0025a0  "}.lst-kix_e2t2rmnqe10-5>li:before{content:"\0025a0  "}.lst-kix_iwdebqq8hf5j-1>li:before{content:"\0025cb  "}ol.lst-kix_aj4nely7012k-0{list-style-type:none}ol.lst-kix_aj4nely7012k-4{list-style-type:none}.lst-kix_8br8rmq8ditp-7>li:before{content:"\0025cb  "}ol.lst-kix_aj4nely7012k-3{list-style-type:none}ol.lst-kix_aj4nely7012k-2{list-style-type:none}ol.lst-kix_aj4nely7012k-1{list-style-type:none}.lst-kix_e2t2rmnqe10-4>li:before{content:"\0025cb  "}.lst-kix_kahinyjwemck-7>li:before{content:"\0025cb  "}.lst-kix_gepharm975nz-7>li:before{content:"\0025cb  "}.lst-kix_iwdebqq8hf5j-6>li:before{content:"\0025cf  "}.lst-kix_iwdebqq8hf5j-5>li:before{content:"\0025a0  "}ol.lst-kix_aj4nely7012k-4.start{counter-reset:lst-ctn-kix_aj4nely7012k-4 0}.lst-kix_iwdebqq8hf5j-2>li:before{content:"\0025a0  "}.lst-kix_kahinyjwemck-8>li:before{content:"\0025a0  "}.lst-kix_gepharm975nz-8>li:before{content:"\0025a0  "}.lst-kix_e2t2rmnqe10-8>li:before{content:"\0025a0  "}.lst-kix_kahinyjwemck-3>li:before{content:"\0025cf  "}.lst-kix_aj4nely7012k-8>li{counter-increment:lst-ctn-kix_aj4nely7012k-8}.lst-kix_kahinyjwemck-4>li:before{content:"\0025cb  "}.lst-kix_e2t2rmnqe10-1>li:before{content:"\0025cb  "}.lst-kix_imtbhan3v8dd-0>li:before{content:"\0025cf  "}.lst-kix_kahinyjwemck-0>li:before{content:"\0025cf  "}.lst-kix_e2t2rmnqe10-0>li:before{content:"\0025cf  "}.lst-kix_7pfod88c1yea-3>li:before{content:"\0025cf  "}.lst-kix_7pfod88c1yea-0>li:before{content:"\0025cf  "}.lst-kix_7pfod88c1yea-4>li:before{content:"\0025cb  "}ul.lst-kix_k03hqnpiq03o-4{list-style-type:none}ul.lst-kix_k03hqnpiq03o-5{list-style-type:none}ul.lst-kix_k03hqnpiq03o-2{list-style-type:none}ul.lst-kix_k03hqnpiq03o-3{list-style-type:none}ul.lst-kix_k03hqnpiq03o-0{list-style-type:none}ul.lst-kix_k03hqnpiq03o-1{list-style-type:none}ul.lst-kix_k03hqnpiq03o-8{list-style-type:none}ul.lst-kix_k03hqnpiq03o-6{list-style-type:none}ul.lst-kix_k03hqnpiq03o-7{list-style-type:none}ul.lst-kix_lv773lffpn0i-8{list-style-type:none}ul.lst-kix_lv773lffpn0i-7{list-style-type:none}ul.lst-kix_lv773lffpn0i-2{list-style-type:none}ul.lst-kix_lv773lffpn0i-1{list-style-type:none}ul.lst-kix_lv773lffpn0i-0{list-style-type:none}ul.lst-kix_lv773lffpn0i-6{list-style-type:none}ul.lst-kix_lv773lffpn0i-5{list-style-type:none}ul.lst-kix_lv773lffpn0i-4{list-style-type:none}ul.lst-kix_lv773lffpn0i-3{list-style-type:none}ul.lst-kix_sols1i8ldw7r-8{list-style-type:none}ul.lst-kix_sols1i8ldw7r-7{list-style-type:none}ul.lst-kix_sols1i8ldw7r-6{list-style-type:none}ul.lst-kix_sols1i8ldw7r-5{list-style-type:none}ul.lst-kix_sols1i8ldw7r-4{list-style-type:none}ul.lst-kix_8br8rmq8ditp-8{list-style-type:none}.lst-kix_7pfod88c1yea-8>li:before{content:"\0025a0  "}ul.lst-kix_8br8rmq8ditp-7{list-style-type:none}ul.lst-kix_8br8rmq8ditp-6{list-style-type:none}.lst-kix_7pfod88c1yea-7>li:before{content:"\0025cb  "}ul.lst-kix_gepharm975nz-4{list-style-type:none}ul.lst-kix_8br8rmq8ditp-1{list-style-type:none}ul.lst-kix_gepharm975nz-5{list-style-type:none}ul.lst-kix_8br8rmq8ditp-0{list-style-type:none}ul.lst-kix_gepharm975nz-6{list-style-type:none}ul.lst-kix_gepharm975nz-7{list-style-type:none}ul.lst-kix_gepharm975nz-8{list-style-type:none}ul.lst-kix_8br8rmq8ditp-5{list-style-type:none}ul.lst-kix_8br8rmq8ditp-4{list-style-type:none}ul.lst-kix_8br8rmq8ditp-3{list-style-type:none}ol.lst-kix_aj4nely7012k-5.start{counter-reset:lst-ctn-kix_aj4nely7012k-5 0}ul.lst-kix_8br8rmq8ditp-2{list-style-type:none}ol.lst-kix_aj4nely7012k-8.start{counter-reset:lst-ctn-kix_aj4nely7012k-8 0}.lst-kix_4gr8286u97kq-0>li:before{content:"\0025cf  "}.lst-kix_gm2clh84i9iz-6>li:before{content:"\0025cf  "}.lst-kix_izk41jo74l0l-1>li:before{content:"\0025cb  "}.lst-kix_o30o65ygwqqk-7>li:before{content:"\0025cb  "}.lst-kix_izk41jo74l0l-5>li:before{content:"\0025a0  "}.lst-kix_aj4nely7012k-4>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-4,lower-latin) ". "}.lst-kix_aj4nely7012k-6>li{counter-increment:lst-ctn-kix_aj4nely7012k-6}.lst-kix_ynkekeqxe98q-1>li:before{content:"\0025cb  "}.lst-kix_aj4nely7012k-0>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-0,decimal) ". "}.lst-kix_k03hqnpiq03o-4>li:before{content:"\0025cb  "}.lst-kix_gm2clh84i9iz-2>li:before{content:"\0025a0  "}.lst-kix_ynkekeqxe98q-5>li:before{content:"\0025a0  "}ul.lst-kix_ka2oxzrbkniw-8{list-style-type:none}ul.lst-kix_ka2oxzrbkniw-7{list-style-type:none}.lst-kix_imtbhan3v8dd-3>li:before{content:"\0025cf  "}.lst-kix_lv773lffpn0i-3>li:before{content:"\0025cf  "}.lst-kix_lv773lffpn0i-7>li:before{content:"\0025cb  "}ul.lst-kix_ka2oxzrbkniw-4{list-style-type:none}.lst-kix_aj4nely7012k-1>li{counter-increment:lst-ctn-kix_aj4nely7012k-1}ul.lst-kix_8q74ckljj7r6-3{list-style-type:none}ul.lst-kix_ka2oxzrbkniw-3{list-style-type:none}ul.lst-kix_8q74ckljj7r6-2{list-style-type:none}ul.lst-kix_ka2oxzrbkniw-6{list-style-type:none}ul.lst-kix_8q74ckljj7r6-1{list-style-type:none}ul.lst-kix_ka2oxzrbkniw-5{list-style-type:none}ul.lst-kix_8q74ckljj7r6-0{list-style-type:none}ul.lst-kix_ka2oxzrbkniw-0{list-style-type:none}ul.lst-kix_ka2oxzrbkniw-2{list-style-type:none}ul.lst-kix_ka2oxzrbkniw-1{list-style-type:none}.lst-kix_qjrdt59nqqfa-0>li:before{content:"\0025cf  "}.lst-kix_qjrdt59nqqfa-8>li:before{content:"\0025a0  "}.lst-kix_brtyuticwpei-0>li:before{content:"\0025cf  "}.lst-kix_k03hqnpiq03o-8>li:before{content:"\0025a0  "}ul.lst-kix_8q74ckljj7r6-7{list-style-type:none}.lst-kix_aj4nely7012k-8>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-8,lower-roman) ". "}ul.lst-kix_8q74ckljj7r6-6{list-style-type:none}ul.lst-kix_8q74ckljj7r6-5{list-style-type:none}.lst-kix_imtbhan3v8dd-7>li:before{content:"\0025cb  "}ul.lst-kix_8q74ckljj7r6-4{list-style-type:none}.lst-kix_qjrdt59nqqfa-4>li:before{content:"\0025cb  "}ul.lst-kix_8q74ckljj7r6-8{list-style-type:none}.lst-kix_cswe036wxytq-4>li:before{content:"\0025cb  "}.lst-kix_cswe036wxytq-8>li:before{content:"\0025a0  "}.lst-kix_o30o65ygwqqk-3>li:before{content:"\0025cf  "}.lst-kix_4gr8286u97kq-8>li:before{content:"\0025a0  "}.lst-kix_gepharm975nz-4>li:before{content:"\0025cb  "}ul.lst-kix_zbz3yiivmxva-5{list-style-type:none}ol.lst-kix_aj4nely7012k-8{list-style-type:none}ul.lst-kix_zbz3yiivmxva-6{list-style-type:none}.lst-kix_8br8rmq8ditp-0>li:before{content:"\0025cf  "}ol.lst-kix_aj4nely7012k-7{list-style-type:none}ul.lst-kix_zbz3yiivmxva-7{list-style-type:none}ol.lst-kix_aj4nely7012k-6{list-style-type:none}ul.lst-kix_zbz3yiivmxva-8{list-style-type:none}ol.lst-kix_aj4nely7012k-5{list-style-type:none}.lst-kix_cswe036wxytq-0>li:before{content:"\0025cf  "}.lst-kix_8br8rmq8ditp-4>li:before{content:"\0025cb  "}ul.lst-kix_zbz3yiivmxva-0{list-style-type:none}ul.lst-kix_zbz3yiivmxva-1{list-style-type:none}.lst-kix_4gr8286u97kq-4>li:before{content:"\0025cb  "}ul.lst-kix_zbz3yiivmxva-2{list-style-type:none}ul.lst-kix_zbz3yiivmxva-3{list-style-type:none}.lst-kix_gepharm975nz-0>li:before{content:"\0025cf  "}ul.lst-kix_zbz3yiivmxva-4{list-style-type:none}ol.lst-kix_aj4nely7012k-1.start{counter-reset:lst-ctn-kix_aj4nely7012k-1 0}ul.lst-kix_cswe036wxytq-0{list-style-type:none}ul.lst-kix_cswe036wxytq-2{list-style-type:none}ul.lst-kix_cswe036wxytq-1{list-style-type:none}ul.lst-kix_cswe036wxytq-4{list-style-type:none}ul.lst-kix_cswe036wxytq-3{list-style-type:none}ul.lst-kix_cswe036wxytq-6{list-style-type:none}ul.lst-kix_cswe036wxytq-5{list-style-type:none}ul.lst-kix_cswe036wxytq-8{list-style-type:none}ul.lst-kix_cswe036wxytq-7{list-style-type:none}.lst-kix_brtyuticwpei-4>li:before{content:"\0025cb  "}.lst-kix_uh37gfupag1c-6>li:before{content:"\0025cf  "}.lst-kix_uh37gfupag1c-5>li:before{content:"\0025a0  "}.lst-kix_uh37gfupag1c-7>li:before{content:"\0025cb  "}.lst-kix_uh37gfupag1c-4>li:before{content:"\0025cb  "}.lst-kix_uh37gfupag1c-8>li:before{content:"\0025a0  "}ol.lst-kix_aj4nely7012k-6.start{counter-reset:lst-ctn-kix_aj4nely7012k-6 0}.lst-kix_brtyuticwpei-5>li:before{content:"\0025a0  "}ul.lst-kix_4gr8286u97kq-7{list-style-type:none}ul.lst-kix_4gr8286u97kq-8{list-style-type:none}.lst-kix_uh37gfupag1c-2>li:before{content:"\0025a0  "}ul.lst-kix_4gr8286u97kq-5{list-style-type:none}ul.lst-kix_4gr8286u97kq-6{list-style-type:none}.lst-kix_brtyuticwpei-6>li:before{content:"\0025cf  "}.lst-kix_brtyuticwpei-7>li:before{content:"\0025cb  "}.lst-kix_uh37gfupag1c-1>li:before{content:"\0025cb  "}.lst-kix_uh37gfupag1c-3>li:before{content:"\0025cf  "}ul.lst-kix_4gr8286u97kq-3{list-style-type:none}ul.lst-kix_4gr8286u97kq-4{list-style-type:none}ul.lst-kix_4gr8286u97kq-1{list-style-type:none}ul.lst-kix_4gr8286u97kq-2{list-style-type:none}.lst-kix_brtyuticwpei-8>li:before{content:"\0025a0  "}ul.lst-kix_4gr8286u97kq-0{list-style-type:none}.lst-kix_aj4nely7012k-2>li{counter-increment:lst-ctn-kix_aj4nely7012k-2}.lst-kix_uh37gfupag1c-0>li:before{content:"\0025cf  "}.lst-kix_gm2clh84i9iz-3>li:before{content:"\0025cf  "}.lst-kix_gm2clh84i9iz-7>li:before{content:"\0025cb  "}.lst-kix_gm2clh84i9iz-5>li:before{content:"\0025a0  "}.lst-kix_ynkekeqxe98q-0>li:before{content:"\0025cf  "}ul.lst-kix_sols1i8ldw7r-3{list-style-type:none}.lst-kix_izk41jo74l0l-2>li:before{content:"\0025a0  "}ul.lst-kix_sols1i8ldw7r-2{list-style-type:none}ul.lst-kix_sols1i8ldw7r-1{list-style-type:none}ul.lst-kix_sols1i8ldw7r-0{list-style-type:none}.lst-kix_aj4nely7012k-5>li{counter-increment:lst-ctn-kix_aj4nely7012k-5}.lst-kix_izk41jo74l0l-4>li:before{content:"\0025cb  "}.lst-kix_izk41jo74l0l-6>li:before{content:"\0025cf  "}.lst-kix_ynkekeqxe98q-8>li:before{content:"\0025a0  "}.lst-kix_izk41jo74l0l-8>li:before{content:"\0025a0  "}.lst-kix_ynkekeqxe98q-2>li:before{content:"\0025a0  "}ul.lst-kix_ynkekeqxe98q-8{list-style-type:none}ul.lst-kix_ynkekeqxe98q-6{list-style-type:none}ul.lst-kix_ynkekeqxe98q-7{list-style-type:none}ul.lst-kix_ynkekeqxe98q-4{list-style-type:none}ul.lst-kix_ynkekeqxe98q-5{list-style-type:none}.lst-kix_ynkekeqxe98q-4>li:before{content:"\0025cb  "}.lst-kix_ynkekeqxe98q-6>li:before{content:"\0025cf  "}.lst-kix_gm2clh84i9iz-1>li:before{content:"\0025cb  "}.lst-kix_brtyuticwpei-3>li:before{content:"\0025cf  "}.lst-kix_lv773lffpn0i-4>li:before{content:"\0025cb  "}.lst-kix_lv773lffpn0i-6>li:before{content:"\0025cf  "}.lst-kix_brtyuticwpei-1>li:before{content:"\0025cb  "}.lst-kix_qjrdt59nqqfa-3>li:before{content:"\0025cf  "}.lst-kix_qjrdt59nqqfa-7>li:before{content:"\0025cb  "}.lst-kix_lv773lffpn0i-0>li:before{content:"\0025cf  "}.lst-kix_lv773lffpn0i-2>li:before{content:"\0025a0  "}.lst-kix_lv773lffpn0i-8>li:before{content:"\0025a0  "}ol.lst-kix_aj4nely7012k-3.start{counter-reset:lst-ctn-kix_aj4nely7012k-3 0}.lst-kix_qjrdt59nqqfa-1>li:before{content:"\0025cb  "}.lst-kix_qjrdt59nqqfa-5>li:before{content:"\0025a0  "}.lst-kix_cswe036wxytq-3>li:before{content:"\0025cf  "}.lst-kix_cswe036wxytq-5>li:before{content:"\0025a0  "}.lst-kix_gepharm975nz-3>li:before{content:"\0025cf  "}.lst-kix_cswe036wxytq-7>li:before{content:"\0025cb  "}.lst-kix_iwdebqq8hf5j-8>li:before{content:"\0025a0  "}.lst-kix_gepharm975nz-1>li:before{content:"\0025cb  "}.lst-kix_cswe036wxytq-1>li:before{content:"\0025cb  "}.lst-kix_iwdebqq8hf5j-0>li:before{content:"\0025cf  "}.lst-kix_e2t2rmnqe10-7>li:before{content:"\0025cb  "}.lst-kix_e2t2rmnqe10-2>li:before{content:"\0025a0  "}.lst-kix_e2t2rmnqe10-6>li:before{content:"\0025cf  "}.lst-kix_8br8rmq8ditp-5>li:before{content:"\0025a0  "}.lst-kix_e2t2rmnqe10-3>li:before{content:"\0025cf  "}.lst-kix_8br8rmq8ditp-6>li:before{content:"\0025cf  "}.lst-kix_kahinyjwemck-6>li:before{content:"\0025cf  "}.lst-kix_gepharm975nz-5>li:before{content:"\0025a0  "}.lst-kix_kahinyjwemck-5>li:before{content:"\0025a0  "}.lst-kix_gepharm975nz-6>li:before{content:"\0025cf  "}.lst-kix_iwdebqq8hf5j-4>li:before{content:"\0025cb  "}.lst-kix_iwdebqq8hf5j-3>li:before{content:"\0025cf  "}.lst-kix_kahinyjwemck-1>li:before{content:"\0025cb  "}.lst-kix_kahinyjwemck-2>li:before{content:"\0025a0  "}.lst-kix_7pfod88c1yea-1>li:before{content:"\0025cb  "}ul.lst-kix_ynkekeqxe98q-2{list-style-type:none}ul.lst-kix_ynkekeqxe98q-3{list-style-type:none}ul.lst-kix_ynkekeqxe98q-0{list-style-type:none}ul.lst-kix_ynkekeqxe98q-1{list-style-type:none}.lst-kix_7pfod88c1yea-2>li:before{content:"\0025a0  "}.lst-kix_izk41jo74l0l-0>li:before{content:"\0025cf  "}.lst-kix_7pfod88c1yea-5>li:before{content:"\0025a0  "}.lst-kix_7pfod88c1yea-6>li:before{content:"\0025cf  "}.lst-kix_gm2clh84i9iz-4>li:before{content:"\0025cb  "}ul.lst-kix_7pfod88c1yea-0{list-style-type:none}.lst-kix_izk41jo74l0l-3>li:before{content:"\0025cf  "}ul.lst-kix_7pfod88c1yea-1{list-style-type:none}ul.lst-kix_7pfod88c1yea-2{list-style-type:none}ul.lst-kix_7pfod88c1yea-3{list-style-type:none}ul.lst-kix_7pfod88c1yea-8{list-style-type:none}.lst-kix_gm2clh84i9iz-8>li:before{content:"\0025a0  "}.lst-kix_izk41jo74l0l-7>li:before{content:"\0025cb  "}.lst-kix_o30o65ygwqqk-5>li:before{content:"\0025a0  "}ul.lst-kix_7pfod88c1yea-4{list-style-type:none}ul.lst-kix_7pfod88c1yea-5{list-style-type:none}ul.lst-kix_7pfod88c1yea-6{list-style-type:none}ul.lst-kix_7pfod88c1yea-7{list-style-type:none}.lst-kix_aj4nely7012k-2>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-2,lower-roman) ". "}.lst-kix_aj4nely7012k-6>li:before{content:"" counter(lst-ctn-kix_aj4nely7012k-6,decimal) ". "}.lst-kix_ynkekeqxe98q-7>li:before{content:"\0025cb  "}ul.lst-kix_gm2clh84i9iz-2{list-style-type:none}ul.lst-kix_gm2clh84i9iz-1{list-style-type:none}ul.lst-kix_gm2clh84i9iz-4{list-style-type:none}ul.lst-kix_gm2clh84i9iz-3{list-style-type:none}ul.lst-kix_gm2clh84i9iz-6{list-style-type:none}ul.lst-kix_gm2clh84i9iz-5{list-style-type:none}ul.lst-kix_gm2clh84i9iz-8{list-style-type:none}ul.lst-kix_gm2clh84i9iz-7{list-style-type:none}ul.lst-kix_gm2clh84i9iz-0{list-style-type:none}.lst-kix_ynkekeqxe98q-3>li:before{content:"\0025cf  "}.lst-kix_gm2clh84i9iz-0>li:before{content:"\0025cf  "}.lst-kix_lv773lffpn0i-5>li:before{content:"\0025a0  "}.lst-kix_qjrdt59nqqfa-6>li:before{content:"\0025cf  "}.lst-kix_brtyuticwpei-2>li:before{content:"\0025a0  "}.lst-kix_imtbhan3v8dd-1>li:before{content:"\0025cb  "}.lst-kix_lv773lffpn0i-1>li:before{content:"\0025cb  "}.lst-kix_qjrdt59nqqfa-2>li:before{content:"\0025a0  "}.lst-kix_k03hqnpiq03o-6>li:before{content:"\0025cf  "}.lst-kix_imtbhan3v8dd-5>li:before{content:"\0025a0  "}ul.lst-kix_uh37gfupag1c-8{list-style-type:none}ul.lst-kix_uh37gfupag1c-3{list-style-type:none}ul.lst-kix_uh37gfupag1c-2{list-style-type:none}ul.lst-kix_uh37gfupag1c-1{list-style-type:none}ul.lst-kix_uh37gfupag1c-0{list-style-type:none}ul.lst-kix_uh37gfupag1c-7{list-style-type:none}ul.lst-kix_uh37gfupag1c-6{list-style-type:none}ul.lst-kix_uh37gfupag1c-5{list-style-type:none}ul.lst-kix_uh37gfupag1c-4{list-style-type:none}ul.lst-kix_imtbhan3v8dd-0{list-style-type:none}ul.lst-kix_imtbhan3v8dd-1{list-style-type:none}ul.lst-kix_imtbhan3v8dd-2{list-style-type:none}.lst-kix_o30o65ygwqqk-1>li:before{content:"\0025cb  "}ul.lst-kix_imtbhan3v8dd-3{list-style-type:none}ul.lst-kix_imtbhan3v8dd-4{list-style-type:none}ul.lst-kix_imtbhan3v8dd-5{list-style-type:none}ul.lst-kix_imtbhan3v8dd-6{list-style-type:none}.lst-kix_4gr8286u97kq-6>li:before{content:"\0025cf  "}ul.lst-kix_imtbhan3v8dd-7{list-style-type:none}ul.lst-kix_imtbhan3v8dd-8{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_iwdebqq8hf5j-7>li:before{content:"\0025cb  "}.lst-kix_cswe036wxytq-6>li:before{content:"\0025cf  "}.lst-kix_4gr8286u97kq-2>li:before{content:"\0025a0  "}.lst-kix_gepharm975nz-2>li:before{content:"\0025a0  "}.lst-kix_8br8rmq8ditp-2>li:before{content:"\0025a0  "}.lst-kix_cswe036wxytq-2>li:before{content:"\0025a0  "}.lst-kix_aj4nely7012k-7>li{counter-increment:lst-ctn-kix_aj4nely7012k-7}ol{margin:0;padding:0}table td,table th{padding:0}.c4{background-color:#ffffff;margin-left:36pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c35{background-color:#ffffff;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c7{background-color:#ffffff;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Cambria Math";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.5pt;font-family:"Courier New";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Courier New";font-style:normal}.c29{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c31{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c19{color:#000000;text-decoration:none;vertical-align:baseline;font-size:10pt;font-style:normal}.c37{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c17{color:#008000;text-decoration:none;vertical-align:baseline;font-style:normal}.c25{font-size:10.5pt;font-family:"Courier New";color:#ff0000;font-weight:700}.c15{font-size:10.5pt;font-family:"Courier New";color:#00ff00;font-weight:700}.c26{font-size:12pt;font-family:"Cambria Math";font-weight:700}.c6{font-size:8pt;font-family:"Courier New";font-weight:400}.c20{font-family:"Cambria Math";font-style:italic;font-weight:700}.c2{font-size:10.5pt;font-family:"Courier New";font-weight:400}.c43{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c24{text-decoration:none;vertical-align:baseline;font-style:normal}.c38{font-weight:700;font-family:"Courier New"}.c18{width:33%;height:1px}.c27{font-weight:700;font-family:"Cambria Math"}.c12{font-weight:400;font-family:"Cambria Math"}.c30{padding:0;margin:0}.c44{font-weight:400;font-family:"Arial"}.c40{color:inherit;text-decoration:inherit}.c13{font-weight:400;font-family:"Courier New"}.c23{font-size:10pt}.c28{color:#001080}.c10{color:#0000ff}.c11{color:#098658}.c3{color:#af00db}.c8{margin-left:72pt}.c33{color:#000000}.c42{color:#008000}.c16{color:#795e26}.c32{margin-left:36pt}.c21{padding-left:0pt}.c36{font-size:14pt}.c14{color:#267f99}.c22{color:#a31515}.c9{height:11pt}.c39{font-size:11pt}.c34{font-size:10.5pt}.c41{text-indent:36pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c43"><p class="c29"><span class="c24 c27 c33 c36">Permutations</span></p><p class="c29"><span class="c26">Objectives</span></p><ul class="c30 lst-kix_4gr8286u97kq-0 start"><li class="c29 c21 c32 li-bullet-0"><span class="c20">Create a new type</span><span class="c12">&nbsp;</span><span class="c13">Permutation</span><span class="c0">, representing the mathematical object of the same name</span></li><li class="c29 c32 c21 li-bullet-0"><span class="c20">Utilise multiple dispatch to create new methods for inbuilt functions</span><span class="c12">&nbsp;with </span><span class="c13">Permutation</span><span class="c0">&nbsp;objects as arguments</span></li><li class="c29 c32 c21 li-bullet-0"><span class="c12">Generate the elements of symmetric/alternating groups in </span><span class="c13">Permutation</span><span class="c12">&nbsp;form</span></li></ul><p class="c9 c29"><span class="c0"></span></p><p class="c29"><span class="c27">Declaring a new type with </span><span class="c24 c38 c10 c39">struct</span></p><p class="c29"><span class="c12">I begin by declaring a new type with the keyword </span><span class="c13 c10">struct</span><span class="c12 c10">&nbsp;</span><span class="c0">as follows:</span></p><p class="c4"><span class="c2 c10">struct</span><span class="c1">&nbsp;Permutation</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; image::</span><span class="c2 c14">Vector{Int64}</span></p><p class="c4"><span class="c2 c24 c3">end</span></p><p class="c7 c9"><span class="c2 c24 c3"></span></p><p class="c7"><span class="c12">In this case, the new type has a single field </span><span class="c13">image</span><span class="c12">&nbsp;which is a vector of integers, representing the images of </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 58.67px; height: 13.33px;"><img alt="" src="images/image5.png" style="width: 58.67px; height: 13.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12">&nbsp;under the permutation (where </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 8.00px; height: 6.67px;"><img alt="" src="images/image3.png" style="width: 8.00px; height: 6.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12">&nbsp;is the maximum integer permuted). For example, the permutation </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 61.33px; height: 16.00px;"><img alt="" src="images/image7.png" style="width: 61.33px; height: 16.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12">&nbsp;has image </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 88.00px; height: 17.33px;"><img alt="" src="images/image2.png" style="width: 88.00px; height: 17.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0">, and can be created as an object by:</span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c2">&nbsp;permutation = </span><span class="c2">Permutation</span><span class="c2">([</span><span class="c2">2</span><span class="c2">,</span><span class="c2">3</span><span class="c2">,</span><span class="c2">1</span><span class="c2">,</span><span class="c2">5</span><span class="c2">,</span><span class="c2">4</span><span class="c1">])</span></p><p class="c4"><span class="c2">Permutation</span><span class="c2">([</span><span class="c2">2</span><span class="c2">, </span><span class="c2">3</span><span class="c2">, </span><span class="c2">1</span><span class="c2">, </span><span class="c2">5</span><span class="c2">, </span><span class="c2">4</span><span class="c1">])</span></p><p class="c7 c9"><span class="c1"></span></p><p class="c7"><span class="c24 c12 c33 c34">Although this object doesn&rsquo;t do anything yet, I can access its fields with dot notation:</span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;permutation.image</span></p><p class="c4"><span class="c1">5-element Vector{Int64}:</span></p><p class="c4"><span class="c1">&nbsp;2</span></p><p class="c4"><span class="c1">&nbsp;3</span></p><p class="c4"><span class="c1">&nbsp;1</span></p><p class="c4"><span class="c1">&nbsp;5</span></p><p class="c4"><span class="c2">&nbsp;4</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c24 c27 c33 c39">Inner constructors</span></p><p class="c7"><span class="c12">Not any vector will do as the image. It must consist of exactly the </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 8.00px; height: 6.67px;"><img alt="" src="images/image3.png" style="width: 8.00px; height: 6.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12">&nbsp;integers </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 58.67px; height: 13.33px;"><img alt="" src="images/image5.png" style="width: 58.67px; height: 13.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12">&nbsp;(for some </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 8.00px; height: 6.67px;"><img alt="" src="images/image3.png" style="width: 8.00px; height: 6.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12">) in any order. To check this, I will use an inner constructor, which is a function inside the </span><span class="c13">struct</span><span class="c12">&nbsp;block which runs instead of the automatic constructor </span><span class="c13">Permutation</span><span class="c0">&nbsp;that was used earlier.</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c12">Suppose that the input is the vector </span><span class="c13">image</span><span class="c0">. I want to check two things:</span></p><ul class="c30 lst-kix_iwdebqq8hf5j-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">Is </span><span class="c13">image</span><span class="c12">&nbsp;valid for constructing a permutation? To check this, I will reorder the vector to be in increasing order, and then compare it to the vector </span><span class="c13">[1,2,...,n]</span><span class="c12">, where </span><span class="c13">n</span><span class="c12">&nbsp;is the last entry in the sorted vector</span><sup class="c12"><a href="#ftnt1" id="ftnt_ref1">[1]</a></sup><span class="c12">. Then, I use the keyword </span><span class="c13 c16">new</span><span class="c12">, specific to inner constructors, which allows the creation a new instance of the type </span><span class="c13">Permutation</span></li></ul><p class="c7 c8"><span class="c2">sortedimage = </span><span class="c2 c16">sort</span><span class="c2">(image)<br>sortedimage == </span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">last</span><span class="c2">(sortedimage) &amp;&amp; </span><span class="c2 c3">return</span><span class="c2">&nbsp;</span><span class="c2 c16">new</span><span class="c1">(image)</span></p><ul class="c30 lst-kix_brtyuticwpei-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">Is </span><span class="c13">image</span><span class="c12">&nbsp;longer than it needs to be? For example, an </span><span class="c13">image</span><span class="c12">&nbsp;of </span><span class="c13">[2,1,3]</span><span class="c12">&nbsp;would give a permutation that acts the same as one with an </span><span class="c13">image</span><span class="c12">&nbsp;of </span><span class="c13">[2,1]</span><span class="c12">, so the extra elements needn&rsquo;t be stored.</span><sup class="c12"><a href="#ftnt2" id="ftnt_ref2">[2]</a></sup><span class="c12">&nbsp;I find the list of integers that aren&rsquo;t fixed by<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2">image[image .!= </span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">length</span><span class="c2">(image)]<br></span><span class="c12">and then find the largest by <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2">m = </span><span class="c2 c16">maximum</span><span class="c2">([image[image .!= </span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">length</span><span class="c2">(image)]..., </span><span class="c2 c11">1</span><span class="c2">])<br></span><span class="c12">with </span><span class="c13">1</span><span class="c12">&nbsp;appended on the end since the list of integers that aren&rsquo;t fixed could be empty and </span><span class="c13 c16">maximum</span><span class="c12 c16">&nbsp;</span><span class="c0">doesn&rsquo;t work with an empty vector</span></li></ul><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c0">Combining these together with an error message into an inner constructor gives:</span></p><p class="c4"><span class="c2 c10">struct</span><span class="c1">&nbsp;Permutation</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; image::</span><span class="c2 c24 c14">Vector{Int64}</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c10">function</span><span class="c2">&nbsp;</span><span class="c2 c16">Permutation</span><span class="c2">(image::</span><span class="c2 c14">Vector{Int64}</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; sortedimage = </span><span class="c2 c16">sort</span><span class="c1">(image)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; m = </span><span class="c2 c16">maximum</span><span class="c2">([image[image .!= </span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">length</span><span class="c2">(image)]..., </span><span class="c2 c11">1</span><span class="c1">])</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; sortedimage == </span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">last</span><span class="c2">(sortedimage) &amp;&amp; </span><span class="c2 c3">return</span><span class="c2">&nbsp;</span><span class="c2 c16">new</span><span class="c2">(image[</span><span class="c2 c11">1</span><span class="c1">:m])</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2 c16">error</span><span class="c2">(</span><span class="c2 c22">&quot;not a valid permutation&quot;</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c24 c3">end</span></p><p class="c4"><span class="c2 c24 c3">end</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;Permutation([2,3,4])</span></p><p class="c4"><span class="c25">ERROR:</span><span class="c1">&nbsp;not a valid permutation</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;Permutation([2,1,3])</span></p><p class="c4"><span class="c1">Permutation([2, 1])</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c24 c27 c33 c39">Outer constructors</span></p><p class="c7"><span class="c0">Outer constructors utilise multiple dispatch to allow for different syntax to construct types. In this instance, I want to be able to construct a permutation by just giving it a list of integers and not having to wrap them up in vector form myself. The outer constructor I have written to do this is:</span></p><p class="c4"><span class="c2 c16">Permutation</span><span class="c2">(imagevals::</span><span class="c2 c14">Int64...</span><span class="c2">) = </span><span class="c2 c16">Permutation</span><span class="c2">([x </span><span class="c2 c3">for</span><span class="c1">&nbsp;x &isin; imagevals])</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&sigma; = Permutation(5,2,1,3,4)</span></p><p class="c4"><span class="c1">Permutation([5, 2, 1, 3, 4])</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c27">Evaluating a permutation as a function</span></p><p class="c7"><span class="c12">The next step is to be able to use a </span><span class="c13">Permutation</span><span class="c0">&nbsp;object as the function that it represents, i.e. evaluate it at an integer. I can do this by</span></p><p class="c7"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2">(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c2">)(x::</span><span class="c2 c14">Int64</span><span class="c1">) = &sigma;.image[x]</span></p><p class="c7 c9"><span class="c1"></span></p><p class="c7"><span class="c12">However, this will give an error for any </span><span class="c13">x</span><span class="c12">&nbsp;which isn&rsquo;t an index of </span><span class="c13">&sigma;.image</span><span class="c12">. Due to my decision to have permutations be bijections of </span><span class="c13">&#8469;</span><span class="c12">&nbsp;instead of bijections of </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 74.67px; height: 16.00px;"><img alt="" src="images/image1.png" style="width: 74.67px; height: 16.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0">, I would like it to return a value for any positive integer (indeed it will work for all integers with this code, which isn&rsquo;t a problem for me):</span></p><p class="c4"><span class="c2 c16">maxarg</span><span class="c2">(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c2">) = </span><span class="c2 c16">length</span><span class="c2">(&sigma;.image)</span></p><p class="c4"><span class="c2">(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c2">)(x::</span><span class="c2 c14">Int64</span><span class="c2">) = x &isin; </span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">maxarg</span><span class="c1">(&sigma;) ? &sigma;.image[x] : x</span></p><p class="c4 c9"><span class="c0"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&sigma;(4)</span></p><p class="c4"><span class="c1">3</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&sigma;(10)</span></p><p class="c4"><span class="c1">10</span></p><p class="c4 c9"><span class="c0"></span></p><p class="c7"><span class="c12">I implement the function </span><span class="c13 c16">maxarg</span><span class="c12">&nbsp;as a shorthand for </span><span class="c13 c16">length</span><span class="c13">(&sigma;.image)</span><span class="c0">&nbsp;since it will be useful in later functions too.</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c27">Creating a custom display format for a </span><span class="c38">Permutation</span><span class="c24 c27 c33 c39">&nbsp;object</span></p><p class="c7"><span class="c12">At the moment, whenever a </span><span class="c13">Permutation</span><span class="c12">&nbsp;object is returned, it has the form </span><span class="c13">Permutation(image)</span><span class="c12">, which isn&rsquo;t very useful. To be more understandable (and more in keeping with standard mathematical notation), I want to customise this displayed form by adding a method to </span><span class="c13">show</span><span class="c12">&nbsp;specifically for the </span><span class="c13">Permutation</span><span class="c0">&nbsp;type.</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c0">The format that I want to display the permutation in is as its disjoint cycle decomposition. To do this, I first need a function to calculate the orbit generated by acting repeatedly on a given element:</span></p><p class="c4"><span class="c2 c10">function</span><span class="c2">&nbsp;</span><span class="c2 c16">orbit</span><span class="c2">(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c2">, x::</span><span class="c2 c14">Int64</span><span class="c1">)</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; orb = [x]</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; y = </span><span class="c2 c16">&sigma;</span><span class="c1">(x)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c3">while</span><span class="c1">&nbsp;y != x</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2 c16">push!</span><span class="c1">(orb,y)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; y = </span><span class="c2 c16">&sigma;</span><span class="c1">(y)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c24 c3">end</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c3">return</span><span class="c1">&nbsp;orb</span></p><p class="c4"><span class="c2 c24 c3">end</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c0">To calculate the disjoint cycle decomposition, I build up the output as follows:</span></p><ul class="c30 lst-kix_zbz3yiivmxva-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">I start out with an empty </span><span class="c13">Vector{Vector{Int64}}</span><span class="c0">&nbsp;(that is, a vector whose elements are vectors of integers)</span></li></ul><p class="c4 c41"><span class="c2">decomp = Vector{Int64}[]</span></p><ul class="c30 lst-kix_sols1i8ldw7r-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">A vector </span><span class="c13">unaccounted</span><span class="c12">&nbsp;tracks which values in the range </span><span class="c13">1:maxarg(&sigma;)</span><span class="c12">&nbsp;are yet to be added to the decomposition. We will iterate until this vector is entirely </span><span class="c24 c13 c33 c39">false</span></li></ul><p class="c7 c8"><span class="c2">unaccounted = </span><span class="c2 c16">trues</span><span class="c2">(</span><span class="c2 c16">maxarg</span><span class="c1">(&sigma;))</span></p><p class="c7 c8"><span class="c2 c3">while</span><span class="c2">&nbsp;</span><span class="c2 c16">any</span><span class="c1">(unaccounted)</span></p><p class="c7 c8"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2 c42"># code to iterate</span></p><p class="c7 c8"><span class="c1">end</span></p><ul class="c30 lst-kix_cswe036wxytq-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">Inside the loop, I will look for the first value which is unaccounted for in the decomposition so far, calculate its orbit, and then update </span><span class="c13">unaccounted</span><span class="c0">&nbsp;accordingly</span></li></ul><p class="c7 c8"><span class="c2">x = </span><span class="c2 c16">findfirst</span><span class="c1">(unaccounted)</span></p><p class="c7 c8"><span class="c2">xorbit = </span><span class="c2 c16">orbit</span><span class="c1">(&sigma;,x)</span></p><p class="c7 c8"><span class="c2">unaccounted[xorbit] .= </span><span class="c2 c24 c10">false</span></p><ul class="c30 lst-kix_gepharm975nz-0 start"><li class="c4 c21 li-bullet-0"><span class="c0">Then, if the orbit is non-trivial, I add it to the decomposition</span></li></ul><p class="c7 c8"><span class="c2 c16">length</span><span class="c2">(xorbit) &gt; </span><span class="c2 c11">1</span><span class="c2">&nbsp;&amp;&amp; </span><span class="c2 c16">push!</span><span class="c1">(decomp,xorbit)</span></p><p class="c7 c8 c9"><span class="c1"></span></p><p class="c7"><span class="c0">Combining this all together gives the function in full:</span></p><p class="c4"><span class="c2 c10">function</span><span class="c2">&nbsp;</span><span class="c2 c16">dcd</span><span class="c2">(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c1">)</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; decomp = Vector{Int64}[]</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; unaccounted = </span><span class="c2 c16">trues</span><span class="c2">(</span><span class="c2 c16">maxarg</span><span class="c1">(&sigma;))</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c3">while</span><span class="c2">&nbsp;</span><span class="c2 c16">any</span><span class="c1">(unaccounted)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; x = </span><span class="c2 c16">findfirst</span><span class="c1">(unaccounted)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; xorbit = </span><span class="c2 c16">orbit</span><span class="c1">(&sigma;,x)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; unaccounted[xorbit] .= </span><span class="c2 c24 c10">false</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2 c16">length</span><span class="c2">(xorbit) &gt; </span><span class="c2 c11">1</span><span class="c2">&nbsp;&amp;&amp; </span><span class="c2 c16">push!</span><span class="c1">(decomp,xorbit)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c24 c3">end</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c3">return</span><span class="c1">&nbsp;decomp</span></p><p class="c4"><span class="c2 c24 c3">end</span></p><p class="c4 c9"><span class="c0"></span></p><p class="c7"><span class="c0">I then need to consider how to build up the string from this decomposition</span></p><ul class="c30 lst-kix_7pfod88c1yea-0 start"><li class="c4 c21 li-bullet-0"><span class="c0">Each cycle from the decomposition will be expressed as an open parenthesis, followed by the list of integers in order, separated by spaces, and then closed with another parenthesis</span></li></ul><p class="c7 c8"><span class="c2">*( </span><span class="c2 c22">&quot;( &quot;</span><span class="c2">, [</span><span class="c2 c22">&quot;</span><span class="c2 c28">$y</span><span class="c2 c22">&nbsp;&quot;</span><span class="c2">&nbsp;</span><span class="c2 c3">for</span><span class="c2">&nbsp;y &isin; x]... , </span><span class="c2 c22">&quot;)&quot;</span><span class="c1">&nbsp;)</span></p><ul class="c30 lst-kix_7pfod88c1yea-0"><li class="c4 c21 li-bullet-0"><span class="c0">This needs to be repeated for all of the cycles in the decomposition</span></li></ul><p class="c7 c8"><span class="c1">toprint =</span></p><p class="c7 c8"><span class="c2">*([ *( </span><span class="c2 c22">&quot;( &quot;</span><span class="c2">, [</span><span class="c2 c22">&quot;</span><span class="c2 c28">$y</span><span class="c2 c22">&nbsp;&quot;</span><span class="c2">&nbsp;</span><span class="c2 c3">for</span><span class="c2">&nbsp;y &isin; x]... , </span><span class="c2 c22">&quot;)&quot;</span><span class="c2">&nbsp;) </span><span class="c2 c3">for</span><span class="c2">&nbsp;x &isin; </span><span class="c2 c16">dcd</span><span class="c2">(&sigma;)]..., </span><span class="c2 c22">&quot;&quot;</span><span class="c2">)</span></p><ul class="c30 lst-kix_izk41jo74l0l-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">Finally, if (and only if) the permutation is the identity permutation, then the string will be empty at this point. Instead, I want to use the symbol </span><span class="c24 c13 c33 c39">&iota;</span></li></ul><p class="c7 c8"><span class="c2">toprint == </span><span class="c2 c22">&quot;&quot;</span><span class="c2">&nbsp;&amp;&amp; (toprint = </span><span class="c2 c22">&quot;&iota;&quot;</span><span class="c1">)</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c12">Importing the method </span><span class="c13">show</span><span class="c0">&nbsp;so that its inbuilt methods don&rsquo;t get overwritten, I get the new method:</span></p><p class="c7"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2 c3">import</span><span class="c2">&nbsp;Base.show</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c4"><span class="c2 c10">function</span><span class="c2">&nbsp;</span><span class="c2 c16">show</span><span class="c2">(io::</span><span class="c2 c14">IO</span><span class="c2">,&sigma;::</span><span class="c2 c14">Permutation</span><span class="c1">)</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; toprint =</span></p><p class="c7 c8"><span class="c2">*([ *( </span><span class="c2 c22">&quot;( &quot;</span><span class="c2">, [</span><span class="c2 c22">&quot;</span><span class="c2 c28">$y</span><span class="c2 c22">&nbsp;&quot;</span><span class="c2">&nbsp;</span><span class="c2 c3">for</span><span class="c2">&nbsp;y &isin; x]... , </span><span class="c2 c22">&quot;)&quot;</span><span class="c2">&nbsp;) </span><span class="c2 c3">for</span><span class="c2">&nbsp;x &isin; </span><span class="c2 c16">dcd</span><span class="c2">(&sigma;)]..., </span><span class="c2 c22">&quot;&quot;</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; toprint == </span><span class="c2 c22">&quot;&quot;</span><span class="c2">&nbsp;&amp;&amp; (toprint = </span><span class="c2 c22">&quot;&iota;&quot;</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c16">print</span><span class="c1">(io, toprint)</span></p><p class="c4"><span class="c2 c3">end</span></p><p class="c4 c9"><span class="c2 c24 c3"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;Permutation(1,4,5,6,3,2)</span></p><p class="c4"><span class="c1">( 2 4 6 )( 3 5 )</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&sigma;</span></p><p class="c4"><span class="c1">( 1 5 4 3 )</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c27">Adding permutation arithmetic</span></p><p class="c7"><span class="c12">I now want to add some arithmetic for combining permutations, starting with a shortcut for the identity. This will be represented by the constant </span><span class="c13">&iota;</span><span class="c12">&nbsp;(mirroring the way it is displayed by </span><span class="c13">show</span><span class="c0">), and is given by:</span></p><p class="c4"><span class="c2 c10">const</span><span class="c2">&nbsp;&iota; = </span><span class="c2 c16">Permutation</span><span class="c2">(</span><span class="c2 c11">1</span><span class="c1">)</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c12">Then, I add two methods to the inbuilt function </span><span class="c13 c16">one</span><span class="c12">&nbsp;allowing it to be obtained either by parsing a permutation, or the </span><span class="c13">Permutation</span><span class="c12">&nbsp;type. Note that the arguments of the functions are not given names, only their types specified, since the type is the only relevant property about the input which is accessed:</span></p><p class="c4"><span class="c2 c3">import</span><span class="c1">&nbsp;Base.one</span></p><p class="c4"><span class="c2 c16">one</span><span class="c2">(::</span><span class="c2 c14">Permutation</span><span class="c1">) = &iota;</span></p><p class="c4"><span class="c2 c16">one</span><span class="c2">(::</span><span class="c2 c14">Type{Permutation}</span><span class="c1">) = &iota;</span></p><p class="c4 c9"><span class="c0"></span></p><p class="c7"><span class="c12">Next, I want to be able to compose permutations, for which I will write new methods for the inbuilt operator </span><span class="c13">&#8728;</span><span class="c12">. In order for an arbitrary number of permutations to be composable, I use an inductive definition which mirrors the definition of composition of functions</span><sup class="c12"><a href="#ftnt3" id="ftnt_ref3">[3]</a></sup><span class="c0">, that is:</span></p><p class="c4"><span class="c1">&#8728;(f) = f</span></p><p class="c4"><span class="c2">&#8728;(f, g) = </span><span class="c2 c16">ComposedFunction</span><span class="c1">(f, g)</span></p><p class="c4"><span class="c1">&#8728;(f, g, h...) = &#8728;(f &#8728; g, h...)</span></p><p class="c4 c9"><span class="c0"></span></p><p class="c7"><span class="c12">Hence, my methods for </span><span class="c13">&#8728;</span><span class="c0">&nbsp;are:</span></p><p class="c4"><span class="c2">&#8728;(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c1">) = &sigma;</span></p><p class="c4"><span class="c2">&#8728;(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c2">, &tau;::</span><span class="c2 c14">Permutation</span><span class="c2">) =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2 c16">Permutation</span><span class="c2">([</span><span class="c2 c16">&sigma;</span><span class="c2">(</span><span class="c2 c16">&tau;</span><span class="c2">(x)) </span><span class="c2 c3">for</span><span class="c2">&nbsp;x &isin; </span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">max</span><span class="c2">(</span><span class="c2 c16">maxarg</span><span class="c2">(&sigma;),</span><span class="c2 c16">maxarg</span><span class="c1">(&tau;))])</span></p><p class="c4"><span class="c2">&#8728;(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c2">, &tau;::</span><span class="c2 c14">Permutation</span><span class="c2">, &upsilon;::</span><span class="c2 c14">Permutation...</span><span class="c1">) = &#8728;(&sigma; &#8728; &tau;, &upsilon;...)</span></p><p class="c4 c9"><span class="c0"></span></p><p class="c7"><span class="c12">Thirdly, I want an inverse function to be able to find the inverse of a permutation. To do this, I need to find the index of each of </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 58.67px; height: 13.33px;"><img alt="" src="images/image5.png" style="width: 58.67px; height: 13.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0">&nbsp;in the image vector and let that be the image of the new permutation, which is done by:</span></p><p class="c4"><span class="c2 c16">inv</span><span class="c2">(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c1">) =</span></p><p class="c4 c41"><span class="c2 c16">Permutation</span><span class="c2">([</span><span class="c2 c16">findfirst</span><span class="c2">(&sigma;.image .== x) </span><span class="c2 c3">for</span><span class="c2">&nbsp;x &isin; </span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">maxarg</span><span class="c1">(&sigma;)])</span></p><p class="c4 c9"><span class="c0"></span></p><p class="c7"><span class="c12">Finally, I want to be able to exponentiate</span><sup class="c12"><a href="#ftnt4" id="ftnt_ref4">[4]</a></sup><span class="c0">&nbsp;by any integer (including zero and negative integers), which can be done using some logic combined with the three operations above:</span></p><p class="c4"><span class="c2 c10">function</span><span class="c2">&nbsp;^(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c2">,n::</span><span class="c2 c14">Int64</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; n == </span><span class="c2 c11">0</span><span class="c2">&nbsp;&amp;&amp; </span><span class="c2 c3">return</span><span class="c2">&nbsp;</span><span class="c2 c16">one</span><span class="c1">(Permutation)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; n &lt; </span><span class="c2 c11">0</span><span class="c2">&nbsp;&amp;&amp; ((n,&sigma;) = (-n,</span><span class="c2 c16">inv</span><span class="c1">(&sigma;)))</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c3">return</span><span class="c2">&nbsp;&#8728;(</span><span class="c2 c16">fill</span><span class="c1">(&sigma;,n)...)</span></p><p class="c4"><span class="c2 c24 c3">end</span></p><p class="c4 c9"><span class="c0"></span></p><p class="c7"><span class="c0">I can now test these out:</span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&iota;</span></p><p class="c4"><span class="c1">&iota;</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&sigma; = Permutation(5,2,1,3,4)</span></p><p class="c4"><span class="c1">( 1 5 4 3 )</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&tau; = Permutation(4,5,2,3,1)</span></p><p class="c4"><span class="c1">( 1 4 3 2 5 )</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&sigma; &#8728; &tau;</span></p><p class="c4"><span class="c1">( 1 3 2 4 )</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&sigma;^-1</span></p><p class="c4"><span class="c1">( 1 3 4 5 )</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c15">julia&gt;</span><span class="c1">&nbsp;&tau;^5</span></p><p class="c4"><span class="c1">&iota;</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c27">Constructing symmetric and alternating groups</span></p><p class="c7"><span class="c0">Before constructing these groups, I will need a quick way of generating transpositions, for which I create a function:</span></p><p class="c4"><span class="c2 c10">function</span><span class="c2">&nbsp;</span><span class="c2 c16">transposition</span><span class="c2">(m::</span><span class="c2 c14">Int64</span><span class="c2">, n::</span><span class="c2 c14">Int64</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; image = </span><span class="c2 c16">collect</span><span class="c2">(</span><span class="c2 c11">1</span><span class="c2">:</span><span class="c2 c16">max</span><span class="c1">(m,n))</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; image[m], image[n] = n, m</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c3">return</span><span class="c2">&nbsp;</span><span class="c2 c16">Permutation</span><span class="c1">(image)</span></p><p class="c4"><span class="c2 c24 c3">end</span></p><p class="c7"><span class="c12">Note that</span><span class="c12">&nbsp;</span><span class="c13 c16">transposition</span><span class="c13">(m,m)</span><span class="c0">&nbsp;returns the identity, which turns out to be exactly what I want.</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c12">Now, I have all the tools to create the symmetric group </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 16.00px; height: 13.33px;"><img alt="" src="images/image4.png" style="width: 16.00px; height: 13.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12">&nbsp;as a vector of </span><span class="c13">Permutation</span><span class="c0">&nbsp;objects, which I will do recursively using the inductive formula</span></p><p class="c32 c35"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 408.00px; height: 16.00px;"><img alt="" src="images/image6.png" style="width: 408.00px; height: 16.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><ul class="c30 lst-kix_imtbhan3v8dd-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">First, I will check that </span><span class="c13">n</span><span class="c0">&nbsp;is positive to avoid non-terminating loops (and also because the group doesn&rsquo;t make sense otherwise)</span></li></ul><p class="c7 c8"><span class="c2">n &ge; </span><span class="c2 c11">1</span><span class="c2">&nbsp;|| </span><span class="c2 c16">error</span><span class="c2">(</span><span class="c2 c22">&quot;symmetric group must have a positive parameter&quot;</span><span class="c1">)</span></p><ul class="c30 lst-kix_uh37gfupag1c-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">Then, I implement the base case of the trivial group when </span><span class="c13">n == 1</span><span class="c0">:</span></li></ul><p class="c4"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2">n == </span><span class="c2 c11">1</span><span class="c2">&nbsp;&amp;&amp; </span><span class="c2 c3">return</span><span class="c2">&nbsp;[&iota;]</span></p><ul class="c30 lst-kix_ka2oxzrbkniw-0 start"><li class="c4 c21 li-bullet-0"><span class="c12">For the recursive step, I copy </span><span class="c13 c16">symmetricgroup</span><span class="c13">(n-</span><span class="c13 c11">1</span><span class="c13">)</span><span class="c12">&nbsp;into a vector </span><span class="c13">n</span><span class="c0">&nbsp;times, and then set up the corresponding vector of transpositions that I will multiply each by, using array filling and concatenation. Then, I compose the two elementwise</span></li></ul><p class="c7 c8"><span class="c2">permutations = </span><span class="c2 c16">vcat</span><span class="c2">(</span><span class="c2 c16">fill</span><span class="c2">(</span><span class="c2 c16">symmetricgroup</span><span class="c2">(n-</span><span class="c2 c11">1</span><span class="c1">),n)...)</span></p><p class="c7 c8"><span class="c1">transpositions =</span></p><p class="c7 c8"><span class="c2">&nbsp; </span><span class="c2 c16">vcat</span><span class="c2">([</span><span class="c2 c16">fill</span><span class="c2">(</span><span class="c2 c16">transposition</span><span class="c2">(i,n),</span><span class="c2 c16">factorial</span><span class="c2">(n-</span><span class="c2 c11">1</span><span class="c2">)) </span><span class="c2 c3">for</span><span class="c2">&nbsp;i &isin; </span><span class="c2 c11">1</span><span class="c1">:n]...)</span></p><p class="c7 c8"><span class="c2 c3">return</span><span class="c1">&nbsp;permutations .&#8728; transpositions</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c0">The entire function is:</span></p><p class="c4"><span class="c2 c10">function</span><span class="c2">&nbsp;</span><span class="c2 c16">symmetricgroup</span><span class="c2">(n::</span><span class="c2 c14">Int64</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; n &ge; </span><span class="c2 c11">1</span><span class="c2">&nbsp;|| </span><span class="c2 c16">error</span><span class="c2">(</span><span class="c2 c22">&quot;symmetric group must have a positive parameter&quot;</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; n == </span><span class="c2 c11">1</span><span class="c2">&nbsp;&amp;&amp; </span><span class="c2 c3">return</span><span class="c1">&nbsp;[&iota;]</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; permutations = </span><span class="c2 c16">vcat</span><span class="c2">(</span><span class="c2 c16">fill</span><span class="c2">(</span><span class="c2 c16">symmetricgroup</span><span class="c2">(n-</span><span class="c2 c11">1</span><span class="c1">),n)...)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; transpositions = </span><span class="c2 c16">vcat</span><span class="c2">([</span><span class="c2 c16">fill</span><span class="c2">(</span><span class="c2 c16">transposition</span><span class="c2">(i,n),</span><span class="c2 c16">factorial</span><span class="c2">(n-</span><span class="c2 c11">1</span><span class="c2">)) </span><span class="c2 c3">for</span><span class="c2">&nbsp;i &isin; </span><span class="c2 c11">1</span><span class="c1">:n]...)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c3">return</span><span class="c1">&nbsp;permutations .&#8728; transpositions</span></p><p class="c4"><span class="c2 c3">end</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c12">To find the alternating group, I need to consider the parity of elements. The easiest way to find the parity of a permutation is to consider it as a product of cycles and consider their parities. I already have such a decomposition, given by </span><span class="c13 c16">dcd</span><span class="c12">, so using the </span><span class="c13 c16">iseven</span><span class="c12">&nbsp;function and </span><span class="c13 c16">sum</span><span class="c12">&nbsp;which counts the number of </span><span class="c13 c10">true</span><span class="c0">&nbsp;elements of an array:</span></p><p class="c7"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c2 c16">parity</span><span class="c2">(&sigma;::</span><span class="c2 c14">Permutation</span><span class="c2">) = (-</span><span class="c2 c11">1</span><span class="c2">)^</span><span class="c2 c16">sum</span><span class="c2">([</span><span class="c2 c16">iseven</span><span class="c2">(</span><span class="c2 c16">length</span><span class="c2">(x)) </span><span class="c2 c3">for</span><span class="c2">&nbsp;x &isin; </span><span class="c2 c16">dcd</span><span class="c1">(&sigma;)])</span></p><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c0">Then, finding the alternating group is just a matter of picking out the elements of the symmetric group with parity 1:</span></p><p class="c4"><span class="c2 c10">function</span><span class="c2">&nbsp;</span><span class="c2 c16">alternatinggroup</span><span class="c2">(n::</span><span class="c2 c14">Int64</span><span class="c1">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; S&#8345; = </span><span class="c2 c16">symmetricgroup</span><span class="c1">(n)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; </span><span class="c2 c3">return</span><span class="c2">&nbsp;S&#8345;[</span><span class="c2 c16">parity</span><span class="c2">.(S&#8345;) .== </span><span class="c2 c11">1</span><span class="c1">]</span></p><p class="c4"><span class="c2 c3 c24">end</span></p><p class="c4 c9"><span class="c2 c24 c3"></span></p><p class="c7"><span class="c26">Further exercises</span></p><ul class="c30 lst-kix_o30o65ygwqqk-0 start"><li class="c4 c21 li-bullet-0"><span class="c0">Write a different implementation of exponentiation for permutations (and perhaps compare efficiency)</span></li><li class="c4 c21 li-bullet-0"><span class="c12">Write functions to find conjugacy classes / centralisers of elements in </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 16.00px; height: 13.33px;"><img alt="" src="images/image4.png" style="width: 16.00px; height: 13.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12">&nbsp;(or trickier, </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 17.33px; height: 13.33px;"><img alt="" src="images/image8.png" style="width: 17.33px; height: 13.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0">)</span></li><li class="c4 c21 li-bullet-0"><span class="c0">Write a function to generate a group (in this case, a vector of permutations) from a list of generators. Since any finite group is a subgroup of a permutation group, you could represent any finite group in this way</span></li><li class="c4 c21 li-bullet-0"><span class="c12">Rewrite the </span><span class="c13">Permutation</span><span class="c0">&nbsp;type to store its data as a list of cycles instead of as a vector representing its image. This will make some operations more efficient and some less</span></li></ul><p class="c7 c9"><span class="c0"></span></p><p class="c7"><span class="c26 c24 c33">Full solution</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c3">import</span><span class="c5">&nbsp;Base.show</span></p><p class="c7"><span class="c6 c3">import</span><span class="c5">&nbsp;Base.one</span></p><p class="c7"><span class="c6 c3">import</span><span class="c5">&nbsp;Base.&#8728;</span></p><p class="c7"><span class="c6 c3">import</span><span class="c5">&nbsp;Base.inv</span></p><p class="c7"><span class="c6 c3">import</span><span class="c5">&nbsp;Base.^</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c10">struct</span><span class="c5">&nbsp;Permutation</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; image::</span><span class="c6 c14">Vector{Int64}</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c10">function</span><span class="c6">&nbsp;</span><span class="c6 c16">Permutation</span><span class="c6">(image::</span><span class="c6 c14">Vector{Int64}</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; sortedimage = </span><span class="c6 c16">sort</span><span class="c5">(image)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; m = </span><span class="c6 c16">maximum</span><span class="c6">([image[image .!= </span><span class="c6 c11">1</span><span class="c6">:</span><span class="c6 c16">length</span><span class="c6">(image)]..., </span><span class="c6 c11">1</span><span class="c5">])</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; sortedimage == </span><span class="c6 c11">1</span><span class="c6">:</span><span class="c6 c16">last</span><span class="c6">(sortedimage) &amp;&amp; </span><span class="c6 c3">return</span><span class="c6">&nbsp;</span><span class="c6 c16">new</span><span class="c6">(image[</span><span class="c6 c11">1</span><span class="c5">:m])</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c16">error</span><span class="c6">(</span><span class="c6 c22">&quot;not a valid permutation&quot;</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c24 c3">end</span></p><p class="c7"><span class="c6 c24 c3">end</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c16">Permutation</span><span class="c6">(imagevals::</span><span class="c6 c14">Int64...</span><span class="c6">) = </span><span class="c6 c16">Permutation</span><span class="c6">([x </span><span class="c6 c3">for</span><span class="c5">&nbsp;x &isin; imagevals])</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c16">maxarg</span><span class="c6">(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c6">) = </span><span class="c6 c16">length</span><span class="c5">(&sigma;.image)</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6">(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c6">)(x::</span><span class="c6 c14">Int64</span><span class="c6">) = x &isin; </span><span class="c6 c11">1</span><span class="c6">:</span><span class="c6 c16">maxarg</span><span class="c5">(&sigma;) ? &sigma;.image[x] : x</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c10">function</span><span class="c6">&nbsp;</span><span class="c6 c16">orbit</span><span class="c6">(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c6">, x::</span><span class="c6 c14">Int64</span><span class="c5">)</span></p><p class="c7"><span class="c5">&nbsp; &nbsp; orb = [x]</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; y = </span><span class="c6 c16">&sigma;</span><span class="c5">(x)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c3">while</span><span class="c5">&nbsp;y != x</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c16">push!</span><span class="c5">(orb,y)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; y = </span><span class="c6 c16">&sigma;</span><span class="c5">(y)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c24 c3">end</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c3">return</span><span class="c5">&nbsp;orb</span></p><p class="c7"><span class="c6 c24 c3">end</span></p><p class="c7 c9"><span class="c6 c17"></span></p><p class="c7"><span class="c6 c10">function</span><span class="c6">&nbsp;</span><span class="c6 c16">dcd</span><span class="c6">(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c5">)</span></p><p class="c7"><span class="c5">&nbsp; &nbsp; decomp = Vector{Int64}[]</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; unaccounted = </span><span class="c6 c16">trues</span><span class="c6">(</span><span class="c6 c16">maxarg</span><span class="c5">(&sigma;))</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c3">while</span><span class="c6">&nbsp;</span><span class="c6 c16">any</span><span class="c5">(unaccounted)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; x = </span><span class="c6 c16">findfirst</span><span class="c5">(unaccounted)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; xorbit = </span><span class="c6 c16">orbit</span><span class="c5">(&sigma;,x)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; unaccounted[xorbit] .= </span><span class="c6 c24 c10">false</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c16">length</span><span class="c6">(xorbit) &gt; </span><span class="c6 c11">1</span><span class="c6">&nbsp;&amp;&amp; </span><span class="c6 c16">push!</span><span class="c5">(decomp,xorbit)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c24 c3">end</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c3">return</span><span class="c5">&nbsp;decomp</span></p><p class="c7"><span class="c6 c24 c3">end</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c10">function</span><span class="c6">&nbsp;</span><span class="c6 c16">show</span><span class="c6">(io::</span><span class="c6 c14">IO</span><span class="c6">,&sigma;::</span><span class="c6 c14">Permutation</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; toprint = *([ *( </span><span class="c6 c22">&quot;( &quot;</span><span class="c6">, [</span><span class="c6 c22">&quot;</span><span class="c6 c28">$y</span><span class="c6 c22">&nbsp;&quot;</span><span class="c6">&nbsp;</span><span class="c6 c3">for</span><span class="c6">&nbsp;y &isin; x]... , </span><span class="c6 c22">&quot;)&quot;</span><span class="c6">&nbsp;) </span><span class="c6 c3">for</span><span class="c6">&nbsp;x &isin; </span><span class="c6 c16">dcd</span><span class="c6">(&sigma;)]..., </span><span class="c6 c22">&quot;&quot;</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; toprint == </span><span class="c6 c22">&quot;&quot;</span><span class="c6">&nbsp;&amp;&amp; (toprint = </span><span class="c6 c22">&quot;&iota;&quot;</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c16">print</span><span class="c5">(io, toprint)</span></p><p class="c7"><span class="c6 c24 c3">end</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c10">const</span><span class="c6">&nbsp;&iota; = </span><span class="c6 c16">Permutation</span><span class="c6">(</span><span class="c6 c11">1</span><span class="c5">)</span></p><p class="c7"><span class="c6 c16">one</span><span class="c6">(::</span><span class="c6 c14">Permutation</span><span class="c5">) = &iota;</span></p><p class="c7"><span class="c6 c16">one</span><span class="c6">(::</span><span class="c6 c14">Type{Permutation}</span><span class="c5">) = &iota;</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6">&#8728;(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c5">) = &sigma;</span></p><p class="c7"><span class="c6">&#8728;(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c6">, &tau;::</span><span class="c6 c14">Permutation</span><span class="c6">) = </span><span class="c6 c16">Permutation</span><span class="c6">([</span><span class="c6 c16">&sigma;</span><span class="c6">(</span><span class="c6 c16">&tau;</span><span class="c6">(x)) </span><span class="c6 c3">for</span><span class="c6">&nbsp;x &isin; </span><span class="c6 c11">1</span><span class="c6">:</span><span class="c6 c16">max</span><span class="c6">(</span><span class="c6 c16">maxarg</span><span class="c6">(&sigma;),</span><span class="c6 c16">maxarg</span><span class="c5">(&tau;))])</span></p><p class="c7"><span class="c6">&#8728;(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c6">, &tau;::</span><span class="c6 c14">Permutation</span><span class="c6">, &upsilon;::</span><span class="c6 c14">Permutation...</span><span class="c5">) = &#8728;(&sigma; &#8728; &tau;, &upsilon;...)</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c16">inv</span><span class="c6">(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c6">) = </span><span class="c6 c16">Permutation</span><span class="c6">([</span><span class="c6 c16">findfirst</span><span class="c6">(&sigma;.image .== x) </span><span class="c6 c3">for</span><span class="c6">&nbsp;x &isin; </span><span class="c6 c11">1</span><span class="c6">:</span><span class="c6 c16">maxarg</span><span class="c5">(&sigma;)])</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c10">function</span><span class="c6">&nbsp;^(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c6">,n::</span><span class="c6 c14">Int64</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; n == </span><span class="c6 c11">0</span><span class="c6">&nbsp;&amp;&amp; </span><span class="c6 c3">return</span><span class="c6">&nbsp;</span><span class="c6 c16">one</span><span class="c5">(Permutation)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; n &lt; </span><span class="c6 c11">0</span><span class="c6">&nbsp;&amp;&amp; ((n,&sigma;) = (-n,</span><span class="c6 c16">inv</span><span class="c5">(&sigma;)))</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c3">return</span><span class="c6">&nbsp;&#8728;(</span><span class="c6 c16">fill</span><span class="c5">(&sigma;,n)...)</span></p><p class="c7"><span class="c6 c24 c3">end</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c10">function</span><span class="c6">&nbsp;</span><span class="c6 c16">transposition</span><span class="c6">(m::</span><span class="c6 c14">Int64</span><span class="c6">, n::</span><span class="c6 c14">Int64</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; image = </span><span class="c6 c16">collect</span><span class="c6">(</span><span class="c6 c11">1</span><span class="c6">:</span><span class="c6 c16">max</span><span class="c5">(m,n))</span></p><p class="c7"><span class="c5">&nbsp; &nbsp; image[m], image[n] = n, m</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c3">return</span><span class="c6">&nbsp;</span><span class="c6 c16">Permutation</span><span class="c5">(image)</span></p><p class="c7"><span class="c6 c24 c3">end</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c10">function</span><span class="c6">&nbsp;</span><span class="c6 c16">symmetricgroup</span><span class="c6">(n::</span><span class="c6 c14">Int64</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; n &ge; </span><span class="c6 c11">1</span><span class="c6">&nbsp;|| </span><span class="c6 c16">error</span><span class="c6">(</span><span class="c6 c22">&quot;symmetric group must have a positive parameter&quot;</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; n == </span><span class="c6 c11">1</span><span class="c6">&nbsp;&amp;&amp; </span><span class="c6 c3">return</span><span class="c5">&nbsp;[&iota;]</span></p><p class="c7 c9"><span class="c5"></span></p><p class="c7"><span class="c6">&nbsp; &nbsp; permutations = </span><span class="c6 c16">vcat</span><span class="c6">(</span><span class="c6 c16">fill</span><span class="c6">(</span><span class="c6 c16">symmetricgroup</span><span class="c6">(n-</span><span class="c6 c11">1</span><span class="c5">),n)...)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; transpositions = </span><span class="c6 c16">vcat</span><span class="c6">([</span><span class="c6 c16">fill</span><span class="c6">(</span><span class="c6 c16">transposition</span><span class="c6">(i,n),</span><span class="c6 c16">factorial</span><span class="c6">(n-</span><span class="c6 c11">1</span><span class="c6">)) </span><span class="c6 c3">for</span><span class="c6">&nbsp;i &isin; </span><span class="c6 c11">1</span><span class="c5">:n]...)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c3">return</span><span class="c5">&nbsp;permutations .&#8728; transpositions</span></p><p class="c7"><span class="c6 c24 c3">end</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c16">parity</span><span class="c6">(&sigma;::</span><span class="c6 c14">Permutation</span><span class="c6">) = (-</span><span class="c6 c11">1</span><span class="c6">)^</span><span class="c6 c16">sum</span><span class="c6">([</span><span class="c6 c16">iseven</span><span class="c6">(</span><span class="c6 c16">length</span><span class="c6">(x)) </span><span class="c6 c3">for</span><span class="c6">&nbsp;x &isin; </span><span class="c6 c16">dcd</span><span class="c5">(&sigma;)])</span></p><p class="c7 c9"><span class="c17 c6"></span></p><p class="c7"><span class="c6 c10">function</span><span class="c6">&nbsp;</span><span class="c6 c16">alternatinggroup</span><span class="c6">(n::</span><span class="c6 c14">Int64</span><span class="c5">)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; S&#8345; = </span><span class="c6 c16">symmetricgroup</span><span class="c5">(n)</span></p><p class="c7"><span class="c6">&nbsp; &nbsp; </span><span class="c6 c3">return</span><span class="c6">&nbsp;S&#8345;[</span><span class="c6 c16">parity</span><span class="c6">.(S&#8345;) .== </span><span class="c6 c11">1</span><span class="c5">]</span></p><p class="c7"><span class="c6 c24 c3">end</span></p><p class="c7 c9"><span class="c0"></span></p><div><p class="c29 c9"><span class="c0"></span></p></div><hr class="c18"><div><p class="c31"><a href="#ftnt_ref1" id="ftnt1">[1]</a><span class="c23">&nbsp;</span><span class="c12">&nbsp;</span><span class="c12 c23">Actually, instead of the vector </span><span class="c13 c23">[1,2,...,n]</span><span class="c12 c23">, I use the expression </span><span class="c13 c23">1:n</span><span class="c12 c23">, which isn&rsquo;t actually a vector, but </span><span class="c13 c23">==</span><span class="c12 c23">&nbsp;recognises it as meaning the same thing</span></p></div><div><p class="c31"><a href="#ftnt_ref2" id="ftnt2">[2]</a><span class="c23">&nbsp;</span><span class="c12 c23">Whether or not this is necessary is a matter of opinion and implementation. If permutations are defined as bijections of a finite set, then the size of that set does matter, so the permutations would be different. In this implementation, I have decided to ignore this, as if taking permutations to be bijections </span><span class="c13 c23">&#8469; &rarr; &#8469;</span><span class="c12 c19">&nbsp;fixing all but &nbsp;finitely many points, and hence want to minimise calculations by reducing in this way</span></p></div><div><p class="c31"><a href="#ftnt_ref3" id="ftnt3">[3]</a><span class="c23">&nbsp;</span><span class="c12 c23">This is found in Julia&rsquo;s source code at </span><span class="c12 c23 c37"><a class="c40" href="https://www.google.com/url?q=https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl%23L940-L942&amp;sa=D&amp;source=editors&amp;ust=1627034425557000&amp;usg=AOvVaw3qDkwioPo_prDEeVhLQ0KX">https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L940-L942</a></span></p></div><div><p class="c31"><a href="#ftnt_ref4" id="ftnt4">[4]</a><span class="c23">&nbsp;</span><span class="c19 c12">There are several possible options for algorithms to do this, including:</span></p><ul class="c30 lst-kix_kahinyjwemck-0 start"><li class="c31 c32 c21 li-bullet-0"><span class="c12 c23">Repeatedly composing the permutation with itself </span><span class="c13 c23">n</span><span class="c19 c12">&nbsp;times (which I have chosen, as it is the simplest)</span></li><li class="c31 c32 c21 li-bullet-0"><span class="c12 c23">Using exponentiation by squaring, which is more efficient for large </span><span class="c13 c23">n</span></li><li class="c31 c32 c21 li-bullet-0"><span class="c19 c12">Using the disjoint cycle decomposition and reversing the cycles</span></li></ul></div></body></html>